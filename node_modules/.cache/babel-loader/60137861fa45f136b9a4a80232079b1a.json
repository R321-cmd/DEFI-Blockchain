{"ast":null,"code":"\"use strict\";\n\nimport _inherits from \"C:/Users/LENOVO.USER/Downloads/Nuevo_defi/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/LENOVO.USER/Downloads/Nuevo_defi/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _classCallCheck from \"C:/Users/LENOVO.USER/Downloads/Nuevo_defi/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/LENOVO.USER/Downloads/Nuevo_defi/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nvar logger = new Logger(version);\n;\nvar _constructorGuard = {};\nvar ModifiersBytes = {\n  calldata: true,\n  memory: true,\n  storage: true\n};\nvar ModifiersNest = {\n  calldata: true,\n  memory: true\n};\nfunction checkModifier(type, name) {\n  if (type === \"bytes\" || type === \"string\") {\n    if (ModifiersBytes[name]) {\n      return true;\n    }\n  } else if (type === \"address\") {\n    if (name === \"payable\") {\n      return true;\n    }\n  } else if (type.indexOf(\"[\") >= 0 || type === \"tuple\") {\n    if (ModifiersNest[name]) {\n      return true;\n    }\n  }\n  if (ModifiersBytes[name] || name === \"payable\") {\n    logger.throwArgumentError(\"invalid modifier\", \"name\", name);\n  }\n  return false;\n}\n// @TODO: Make sure that children of an indexed tuple are marked with a null indexed\nfunction parseParamType(param, allowIndexed) {\n  var originalParam = param;\n  function throwError(i) {\n    logger.throwArgumentError(\"unexpected character at position \".concat(i), \"param\", param);\n  }\n  param = param.replace(/\\s/g, \" \");\n  function newNode(parent) {\n    var node = {\n      type: \"\",\n      name: \"\",\n      parent: parent,\n      state: {\n        allowType: true\n      }\n    };\n    if (allowIndexed) {\n      node.indexed = false;\n    }\n    return node;\n  }\n  var parent = {\n    type: \"\",\n    name: \"\",\n    state: {\n      allowType: true\n    }\n  };\n  var node = parent;\n  for (var i = 0; i < param.length; i++) {\n    var c = param[i];\n    switch (c) {\n      case \"(\":\n        if (node.state.allowType && node.type === \"\") {\n          node.type = \"tuple\";\n        } else if (!node.state.allowParams) {\n          throwError(i);\n        }\n        node.state.allowType = false;\n        node.type = verifyType(node.type);\n        node.components = [newNode(node)];\n        node = node.components[0];\n        break;\n      case \")\":\n        delete node.state;\n        if (node.name === \"indexed\") {\n          if (!allowIndexed) {\n            throwError(i);\n          }\n          node.indexed = true;\n          node.name = \"\";\n        }\n        if (checkModifier(node.type, node.name)) {\n          node.name = \"\";\n        }\n        node.type = verifyType(node.type);\n        var child = node;\n        node = node.parent;\n        if (!node) {\n          throwError(i);\n        }\n        delete child.parent;\n        node.state.allowParams = false;\n        node.state.allowName = true;\n        node.state.allowArray = true;\n        break;\n      case \",\":\n        delete node.state;\n        if (node.name === \"indexed\") {\n          if (!allowIndexed) {\n            throwError(i);\n          }\n          node.indexed = true;\n          node.name = \"\";\n        }\n        if (checkModifier(node.type, node.name)) {\n          node.name = \"\";\n        }\n        node.type = verifyType(node.type);\n        var sibling = newNode(node.parent);\n        //{ type: \"\", name: \"\", parent: node.parent, state: { allowType: true } };\n        node.parent.components.push(sibling);\n        delete node.parent;\n        node = sibling;\n        break;\n      // Hit a space...\n      case \" \":\n        // If reading type, the type is done and may read a param or name\n        if (node.state.allowType) {\n          if (node.type !== \"\") {\n            node.type = verifyType(node.type);\n            delete node.state.allowType;\n            node.state.allowName = true;\n            node.state.allowParams = true;\n          }\n        }\n        // If reading name, the name is done\n        if (node.state.allowName) {\n          if (node.name !== \"\") {\n            if (node.name === \"indexed\") {\n              if (!allowIndexed) {\n                throwError(i);\n              }\n              if (node.indexed) {\n                throwError(i);\n              }\n              node.indexed = true;\n              node.name = \"\";\n            } else if (checkModifier(node.type, node.name)) {\n              node.name = \"\";\n            } else {\n              node.state.allowName = false;\n            }\n          }\n        }\n        break;\n      case \"[\":\n        if (!node.state.allowArray) {\n          throwError(i);\n        }\n        node.type += c;\n        node.state.allowArray = false;\n        node.state.allowName = false;\n        node.state.readArray = true;\n        break;\n      case \"]\":\n        if (!node.state.readArray) {\n          throwError(i);\n        }\n        node.type += c;\n        node.state.readArray = false;\n        node.state.allowArray = true;\n        node.state.allowName = true;\n        break;\n      default:\n        if (node.state.allowType) {\n          node.type += c;\n          node.state.allowParams = true;\n          node.state.allowArray = true;\n        } else if (node.state.allowName) {\n          node.name += c;\n          delete node.state.allowArray;\n        } else if (node.state.readArray) {\n          node.type += c;\n        } else {\n          throwError(i);\n        }\n    }\n  }\n  if (node.parent) {\n    logger.throwArgumentError(\"unexpected eof\", \"param\", param);\n  }\n  delete parent.state;\n  if (node.name === \"indexed\") {\n    if (!allowIndexed) {\n      throwError(originalParam.length - 7);\n    }\n    if (node.indexed) {\n      throwError(originalParam.length - 7);\n    }\n    node.indexed = true;\n    node.name = \"\";\n  } else if (checkModifier(node.type, node.name)) {\n    node.name = \"\";\n  }\n  parent.type = verifyType(parent.type);\n  return parent;\n}\nfunction populate(object, params) {\n  for (var key in params) {\n    defineReadOnly(object, key, params[key]);\n  }\n}\nexport var FormatTypes = Object.freeze({\n  // Bare formatting, as is needed for computing a sighash of an event or function\n  sighash: \"sighash\",\n  // Human-Readable with Minimal spacing and without names (compact human-readable)\n  minimal: \"minimal\",\n  // Human-Readble with nice spacing, including all names\n  full: \"full\",\n  // JSON-format a la Solidity\n  json: \"json\"\n});\nvar paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\nexport var ParamType = /*#__PURE__*/function () {\n  function ParamType(constructorGuard, params) {\n    _classCallCheck(this, ParamType);\n    if (constructorGuard !== _constructorGuard) {\n      logger.throwError(\"use fromString\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"new ParamType()\"\n      });\n    }\n    populate(this, params);\n    var match = this.type.match(paramTypeArray);\n    if (match) {\n      populate(this, {\n        arrayLength: parseInt(match[2] || \"-1\"),\n        arrayChildren: ParamType.fromObject({\n          type: match[1],\n          components: this.components\n        }),\n        baseType: \"array\"\n      });\n    } else {\n      populate(this, {\n        arrayLength: null,\n        arrayChildren: null,\n        baseType: this.components != null ? \"tuple\" : this.type\n      });\n    }\n    this._isParamType = true;\n    Object.freeze(this);\n  }\n  // Format the parameter fragment\n  //   - sighash: \"(uint256,address)\"\n  //   - minimal: \"tuple(uint256,address) indexed\"\n  //   - full:    \"tuple(uint256 foo, addres bar) indexed baz\"\n  _createClass(ParamType, [{\n    key: \"format\",\n    value: function format(_format) {\n      if (!_format) {\n        _format = FormatTypes.sighash;\n      }\n      if (!FormatTypes[_format]) {\n        logger.throwArgumentError(\"invalid format type\", \"format\", _format);\n      }\n      if (_format === FormatTypes.json) {\n        var _result = {\n          type: this.baseType === \"tuple\" ? \"tuple\" : this.type,\n          name: this.name || undefined\n        };\n        if (typeof this.indexed === \"boolean\") {\n          _result.indexed = this.indexed;\n        }\n        if (this.components) {\n          _result.components = this.components.map(function (comp) {\n            return JSON.parse(comp.format(_format));\n          });\n        }\n        return JSON.stringify(_result);\n      }\n      var result = \"\";\n      // Array\n      if (this.baseType === \"array\") {\n        result += this.arrayChildren.format(_format);\n        result += \"[\" + (this.arrayLength < 0 ? \"\" : String(this.arrayLength)) + \"]\";\n      } else {\n        if (this.baseType === \"tuple\") {\n          if (_format !== FormatTypes.sighash) {\n            result += this.type;\n          }\n          result += \"(\" + this.components.map(function (comp) {\n            return comp.format(_format);\n          }).join(_format === FormatTypes.full ? \", \" : \",\") + \")\";\n        } else {\n          result += this.type;\n        }\n      }\n      if (_format !== FormatTypes.sighash) {\n        if (this.indexed === true) {\n          result += \" indexed\";\n        }\n        if (_format === FormatTypes.full && this.name) {\n          result += \" \" + this.name;\n        }\n      }\n      return result;\n    }\n  }], [{\n    key: \"from\",\n    value: function from(value, allowIndexed) {\n      if (typeof value === \"string\") {\n        return ParamType.fromString(value, allowIndexed);\n      }\n      return ParamType.fromObject(value);\n    }\n  }, {\n    key: \"fromObject\",\n    value: function fromObject(value) {\n      if (ParamType.isParamType(value)) {\n        return value;\n      }\n      return new ParamType(_constructorGuard, {\n        name: value.name || null,\n        type: verifyType(value.type),\n        indexed: value.indexed == null ? null : !!value.indexed,\n        components: value.components ? value.components.map(ParamType.fromObject) : null\n      });\n    }\n  }, {\n    key: \"fromString\",\n    value: function fromString(value, allowIndexed) {\n      function ParamTypify(node) {\n        return ParamType.fromObject({\n          name: node.name,\n          type: node.type,\n          indexed: node.indexed,\n          components: node.components\n        });\n      }\n      return ParamTypify(parseParamType(value, !!allowIndexed));\n    }\n  }, {\n    key: \"isParamType\",\n    value: function isParamType(value) {\n      return !!(value != null && value._isParamType);\n    }\n  }]);\n  return ParamType;\n}();\n;\nfunction parseParams(value, allowIndex) {\n  return splitNesting(value).map(function (param) {\n    return ParamType.fromString(param, allowIndex);\n  });\n}\nexport var Fragment = /*#__PURE__*/function () {\n  function Fragment(constructorGuard, params) {\n    _classCallCheck(this, Fragment);\n    if (constructorGuard !== _constructorGuard) {\n      logger.throwError(\"use a static from method\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"new Fragment()\"\n      });\n    }\n    populate(this, params);\n    this._isFragment = true;\n    Object.freeze(this);\n  }\n  _createClass(Fragment, null, [{\n    key: \"from\",\n    value: function from(value) {\n      if (Fragment.isFragment(value)) {\n        return value;\n      }\n      if (typeof value === \"string\") {\n        return Fragment.fromString(value);\n      }\n      return Fragment.fromObject(value);\n    }\n  }, {\n    key: \"fromObject\",\n    value: function fromObject(value) {\n      if (Fragment.isFragment(value)) {\n        return value;\n      }\n      switch (value.type) {\n        case \"function\":\n          return FunctionFragment.fromObject(value);\n        case \"event\":\n          return EventFragment.fromObject(value);\n        case \"constructor\":\n          return ConstructorFragment.fromObject(value);\n        case \"fallback\":\n        case \"receive\":\n          // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?\n          return null;\n      }\n      return logger.throwArgumentError(\"invalid fragment object\", \"value\", value);\n    }\n  }, {\n    key: \"fromString\",\n    value: function fromString(value) {\n      // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n      value = value.replace(/\\s/g, \" \");\n      value = value.replace(/\\(/g, \" (\").replace(/\\)/g, \") \").replace(/\\s+/g, \" \");\n      value = value.trim();\n      if (value.split(\" \")[0] === \"event\") {\n        return EventFragment.fromString(value.substring(5).trim());\n      } else if (value.split(\" \")[0] === \"function\") {\n        return FunctionFragment.fromString(value.substring(8).trim());\n      } else if (value.split(\"(\")[0].trim() === \"constructor\") {\n        return ConstructorFragment.fromString(value.trim());\n      }\n      return logger.throwArgumentError(\"unsupported fragment\", \"value\", value);\n    }\n  }, {\n    key: \"isFragment\",\n    value: function isFragment(value) {\n      return !!(value && value._isFragment);\n    }\n  }]);\n  return Fragment;\n}();\nexport var EventFragment = /*#__PURE__*/function (_Fragment) {\n  _inherits(EventFragment, _Fragment);\n  var _super = _createSuper(EventFragment);\n  function EventFragment() {\n    _classCallCheck(this, EventFragment);\n    return _super.apply(this, arguments);\n  }\n  _createClass(EventFragment, [{\n    key: \"format\",\n    value: function format(_format2) {\n      if (!_format2) {\n        _format2 = FormatTypes.sighash;\n      }\n      if (!FormatTypes[_format2]) {\n        logger.throwArgumentError(\"invalid format type\", \"format\", _format2);\n      }\n      if (_format2 === FormatTypes.json) {\n        return JSON.stringify({\n          type: \"event\",\n          anonymous: this.anonymous,\n          name: this.name,\n          inputs: this.inputs.map(function (input) {\n            return JSON.parse(input.format(_format2));\n          })\n        });\n      }\n      var result = \"\";\n      if (_format2 !== FormatTypes.sighash) {\n        result += \"event \";\n      }\n      result += this.name + \"(\" + this.inputs.map(function (input) {\n        return input.format(_format2);\n      }).join(_format2 === FormatTypes.full ? \", \" : \",\") + \") \";\n      if (_format2 !== FormatTypes.sighash) {\n        if (this.anonymous) {\n          result += \"anonymous \";\n        }\n      }\n      return result.trim();\n    }\n  }], [{\n    key: \"from\",\n    value: function from(value) {\n      if (typeof value === \"string\") {\n        return EventFragment.fromString(value);\n      }\n      return EventFragment.fromObject(value);\n    }\n  }, {\n    key: \"fromObject\",\n    value: function fromObject(value) {\n      if (EventFragment.isEventFragment(value)) {\n        return value;\n      }\n      if (value.type !== \"event\") {\n        logger.throwArgumentError(\"invalid event object\", \"value\", value);\n      }\n      var params = {\n        name: verifyIdentifier(value.name),\n        anonymous: value.anonymous,\n        inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],\n        type: \"event\"\n      };\n      return new EventFragment(_constructorGuard, params);\n    }\n  }, {\n    key: \"fromString\",\n    value: function fromString(value) {\n      var match = value.match(regexParen);\n      if (!match) {\n        logger.throwArgumentError(\"invalid event string\", \"value\", value);\n      }\n      var anonymous = false;\n      match[3].split(\" \").forEach(function (modifier) {\n        switch (modifier.trim()) {\n          case \"anonymous\":\n            anonymous = true;\n            break;\n          case \"\":\n            break;\n          default:\n            logger.warn(\"unknown modifier: \" + modifier);\n        }\n      });\n      return EventFragment.fromObject({\n        name: match[1].trim(),\n        anonymous: anonymous,\n        inputs: parseParams(match[2], true),\n        type: \"event\"\n      });\n    }\n  }, {\n    key: \"isEventFragment\",\n    value: function isEventFragment(value) {\n      return value && value._isFragment && value.type === \"event\";\n    }\n  }]);\n  return EventFragment;\n}(Fragment);\nfunction parseGas(value, params) {\n  params.gas = null;\n  var comps = value.split(\"@\");\n  if (comps.length !== 1) {\n    if (comps.length > 2) {\n      logger.throwArgumentError(\"invalid human-readable ABI signature\", \"value\", value);\n    }\n    if (!comps[1].match(/^[0-9]+$/)) {\n      logger.throwArgumentError(\"invalid human-readable ABI signature gas\", \"value\", value);\n    }\n    params.gas = BigNumber.from(comps[1]);\n    return comps[0];\n  }\n  return value;\n}\nfunction parseModifiers(value, params) {\n  params.constant = false;\n  params.payable = false;\n  params.stateMutability = \"nonpayable\";\n  value.split(\" \").forEach(function (modifier) {\n    switch (modifier.trim()) {\n      case \"constant\":\n        params.constant = true;\n        break;\n      case \"payable\":\n        params.payable = true;\n        params.stateMutability = \"payable\";\n        break;\n      case \"nonpayable\":\n        params.payable = false;\n        params.stateMutability = \"nonpayable\";\n        break;\n      case \"pure\":\n        params.constant = true;\n        params.stateMutability = \"pure\";\n        break;\n      case \"view\":\n        params.constant = true;\n        params.stateMutability = \"view\";\n        break;\n      case \"external\":\n      case \"public\":\n      case \"\":\n        break;\n      default:\n        console.log(\"unknown modifier: \" + modifier);\n    }\n  });\n}\nfunction verifyState(value) {\n  var result = {\n    constant: false,\n    payable: true,\n    stateMutability: \"payable\"\n  };\n  if (value.stateMutability != null) {\n    result.stateMutability = value.stateMutability;\n    // Set (and check things are consistent) the constant property\n    result.constant = result.stateMutability === \"view\" || result.stateMutability === \"pure\";\n    if (value.constant != null) {\n      if (!!value.constant !== result.constant) {\n        logger.throwArgumentError(\"cannot have constant function with mutability \" + result.stateMutability, \"value\", value);\n      }\n    }\n    // Set (and check things are consistent) the payable property\n    result.payable = result.stateMutability === \"payable\";\n    if (value.payable != null) {\n      if (!!value.payable !== result.payable) {\n        logger.throwArgumentError(\"cannot have payable function with mutability \" + result.stateMutability, \"value\", value);\n      }\n    }\n  } else if (value.payable != null) {\n    result.payable = !!value.payable;\n    // If payable we can assume non-constant; otherwise we can't assume\n    if (value.constant == null && !result.payable && value.type !== \"constructor\") {\n      logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n    }\n    result.constant = !!value.constant;\n    if (result.constant) {\n      result.stateMutability = \"view\";\n    } else {\n      result.stateMutability = result.payable ? \"payable\" : \"nonpayable\";\n    }\n    if (result.payable && result.constant) {\n      logger.throwArgumentError(\"cannot have constant payable function\", \"value\", value);\n    }\n  } else if (value.constant != null) {\n    result.constant = !!value.constant;\n    result.payable = !result.constant;\n    result.stateMutability = result.constant ? \"view\" : \"payable\";\n  } else if (value.type !== \"constructor\") {\n    logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n  }\n  return result;\n}\nexport var ConstructorFragment = /*#__PURE__*/function (_Fragment2) {\n  _inherits(ConstructorFragment, _Fragment2);\n  var _super2 = _createSuper(ConstructorFragment);\n  function ConstructorFragment() {\n    _classCallCheck(this, ConstructorFragment);\n    return _super2.apply(this, arguments);\n  }\n  _createClass(ConstructorFragment, [{\n    key: \"format\",\n    value: function format(_format3) {\n      if (!_format3) {\n        _format3 = FormatTypes.sighash;\n      }\n      if (!FormatTypes[_format3]) {\n        logger.throwArgumentError(\"invalid format type\", \"format\", _format3);\n      }\n      if (_format3 === FormatTypes.json) {\n        return JSON.stringify({\n          type: \"constructor\",\n          stateMutability: this.stateMutability !== \"nonpayable\" ? this.stateMutability : undefined,\n          payble: this.payable,\n          gas: this.gas ? this.gas.toNumber() : undefined,\n          inputs: this.inputs.map(function (input) {\n            return JSON.parse(input.format(_format3));\n          })\n        });\n      }\n      if (_format3 === FormatTypes.sighash) {\n        logger.throwError(\"cannot format a constructor for sighash\", Logger.errors.UNSUPPORTED_OPERATION, {\n          operation: \"format(sighash)\"\n        });\n      }\n      var result = \"constructor(\" + this.inputs.map(function (input) {\n        return input.format(_format3);\n      }).join(_format3 === FormatTypes.full ? \", \" : \",\") + \") \";\n      if (this.stateMutability && this.stateMutability !== \"nonpayable\") {\n        result += this.stateMutability + \" \";\n      }\n      return result.trim();\n    }\n  }], [{\n    key: \"from\",\n    value: function from(value) {\n      if (typeof value === \"string\") {\n        return ConstructorFragment.fromString(value);\n      }\n      return ConstructorFragment.fromObject(value);\n    }\n  }, {\n    key: \"fromObject\",\n    value: function fromObject(value) {\n      if (ConstructorFragment.isConstructorFragment(value)) {\n        return value;\n      }\n      if (value.type !== \"constructor\") {\n        logger.throwArgumentError(\"invalid constructor object\", \"value\", value);\n      }\n      var state = verifyState(value);\n      if (state.constant) {\n        logger.throwArgumentError(\"constructor cannot be constant\", \"value\", value);\n      }\n      var params = {\n        name: null,\n        type: value.type,\n        inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],\n        payable: state.payable,\n        stateMutability: state.stateMutability,\n        gas: value.gas ? BigNumber.from(value.gas) : null\n      };\n      return new ConstructorFragment(_constructorGuard, params);\n    }\n  }, {\n    key: \"fromString\",\n    value: function fromString(value) {\n      var params = {\n        type: \"constructor\"\n      };\n      value = parseGas(value, params);\n      var parens = value.match(regexParen);\n      if (!parens || parens[1].trim() !== \"constructor\") {\n        logger.throwArgumentError(\"invalid constructor string\", \"value\", value);\n      }\n      params.inputs = parseParams(parens[2].trim(), false);\n      parseModifiers(parens[3].trim(), params);\n      return ConstructorFragment.fromObject(params);\n    }\n  }, {\n    key: \"isConstructorFragment\",\n    value: function isConstructorFragment(value) {\n      return value && value._isFragment && value.type === \"constructor\";\n    }\n  }]);\n  return ConstructorFragment;\n}(Fragment);\nexport var FunctionFragment = /*#__PURE__*/function (_ConstructorFragment) {\n  _inherits(FunctionFragment, _ConstructorFragment);\n  var _super3 = _createSuper(FunctionFragment);\n  function FunctionFragment() {\n    _classCallCheck(this, FunctionFragment);\n    return _super3.apply(this, arguments);\n  }\n  _createClass(FunctionFragment, [{\n    key: \"format\",\n    value: function format(_format4) {\n      if (!_format4) {\n        _format4 = FormatTypes.sighash;\n      }\n      if (!FormatTypes[_format4]) {\n        logger.throwArgumentError(\"invalid format type\", \"format\", _format4);\n      }\n      if (_format4 === FormatTypes.json) {\n        return JSON.stringify({\n          type: \"function\",\n          name: this.name,\n          constant: this.constant,\n          stateMutability: this.stateMutability !== \"nonpayable\" ? this.stateMutability : undefined,\n          payble: this.payable,\n          gas: this.gas ? this.gas.toNumber() : undefined,\n          inputs: this.inputs.map(function (input) {\n            return JSON.parse(input.format(_format4));\n          }),\n          ouputs: this.outputs.map(function (output) {\n            return JSON.parse(output.format(_format4));\n          })\n        });\n      }\n      var result = \"\";\n      if (_format4 !== FormatTypes.sighash) {\n        result += \"function \";\n      }\n      result += this.name + \"(\" + this.inputs.map(function (input) {\n        return input.format(_format4);\n      }).join(_format4 === FormatTypes.full ? \", \" : \",\") + \") \";\n      if (_format4 !== FormatTypes.sighash) {\n        if (this.stateMutability) {\n          if (this.stateMutability !== \"nonpayable\") {\n            result += this.stateMutability + \" \";\n          }\n        } else if (this.constant) {\n          result += \"view \";\n        }\n        if (this.outputs && this.outputs.length) {\n          result += \"returns (\" + this.outputs.map(function (output) {\n            return output.format(_format4);\n          }).join(\", \") + \") \";\n        }\n        if (this.gas != null) {\n          result += \"@\" + this.gas.toString() + \" \";\n        }\n      }\n      return result.trim();\n    }\n  }], [{\n    key: \"from\",\n    value: function from(value) {\n      if (typeof value === \"string\") {\n        return FunctionFragment.fromString(value);\n      }\n      return FunctionFragment.fromObject(value);\n    }\n  }, {\n    key: \"fromObject\",\n    value: function fromObject(value) {\n      if (FunctionFragment.isFunctionFragment(value)) {\n        return value;\n      }\n      if (value.type !== \"function\") {\n        logger.throwArgumentError(\"invalid function object\", \"value\", value);\n      }\n      var state = verifyState(value);\n      var params = {\n        type: value.type,\n        name: verifyIdentifier(value.name),\n        constant: state.constant,\n        inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],\n        outputs: value.outputs ? value.outputs.map(ParamType.fromObject) : [],\n        payable: state.payable,\n        stateMutability: state.stateMutability,\n        gas: value.gas ? BigNumber.from(value.gas) : null\n      };\n      return new FunctionFragment(_constructorGuard, params);\n    }\n  }, {\n    key: \"fromString\",\n    value: function fromString(value) {\n      var params = {\n        type: \"function\"\n      };\n      value = parseGas(value, params);\n      var comps = value.split(\" returns \");\n      if (comps.length > 2) {\n        logger.throwArgumentError(\"invalid function string\", \"value\", value);\n      }\n      var parens = comps[0].match(regexParen);\n      if (!parens) {\n        logger.throwArgumentError(\"invalid function signature\", \"value\", value);\n      }\n      params.name = parens[1].trim();\n      if (params.name) {\n        verifyIdentifier(params.name);\n      }\n      params.inputs = parseParams(parens[2], false);\n      parseModifiers(parens[3].trim(), params);\n      // We have outputs\n      if (comps.length > 1) {\n        var returns = comps[1].match(regexParen);\n        if (returns[1].trim() != \"\" || returns[3].trim() != \"\") {\n          logger.throwArgumentError(\"unexpected tokens\", \"value\", value);\n        }\n        params.outputs = parseParams(returns[2], false);\n      } else {\n        params.outputs = [];\n      }\n      return FunctionFragment.fromObject(params);\n    }\n  }, {\n    key: \"isFunctionFragment\",\n    value: function isFunctionFragment(value) {\n      return value && value._isFragment && value.type === \"function\";\n    }\n  }]);\n  return FunctionFragment;\n}(ConstructorFragment);\n//export class ErrorFragment extends Fragment {\n//}\n//export class StructFragment extends Fragment {\n//}\nfunction verifyType(type) {\n  // These need to be transformed to their full description\n  if (type.match(/^uint($|[^1-9])/)) {\n    type = \"uint256\" + type.substring(4);\n  } else if (type.match(/^int($|[^1-9])/)) {\n    type = \"int256\" + type.substring(3);\n  }\n  // @TODO: more verification\n  return type;\n}\nvar regexIdentifier = new RegExp(\"^[A-Za-z_][A-Za-z0-9_]*$\");\nfunction verifyIdentifier(value) {\n  if (!value || !value.match(regexIdentifier)) {\n    logger.throwArgumentError(\"invalid identifier \\\"\".concat(value, \"\\\"\"), \"value\", value);\n  }\n  return value;\n}\nvar regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\nfunction splitNesting(value) {\n  value = value.trim();\n  var result = [];\n  var accum = \"\";\n  var depth = 0;\n  for (var offset = 0; offset < value.length; offset++) {\n    var c = value[offset];\n    if (c === \",\" && depth === 0) {\n      result.push(accum);\n      accum = \"\";\n    } else {\n      accum += c;\n      if (c === \"(\") {\n        depth++;\n      } else if (c === \")\") {\n        depth--;\n        if (depth === -1) {\n          logger.throwArgumentError(\"unbalanced parenthesis\", \"value\", value);\n        }\n      }\n    }\n  }\n  if (accum) {\n    result.push(accum);\n  }\n  return result;\n}","map":{"version":3,"names":["_inherits","_createSuper","_classCallCheck","_createClass","BigNumber","defineReadOnly","Logger","version","logger","_constructorGuard","ModifiersBytes","calldata","memory","storage","ModifiersNest","checkModifier","type","name","indexOf","throwArgumentError","parseParamType","param","allowIndexed","originalParam","throwError","i","concat","replace","newNode","parent","node","state","allowType","indexed","length","c","allowParams","verifyType","components","child","allowName","allowArray","sibling","push","readArray","populate","object","params","key","FormatTypes","Object","freeze","sighash","minimal","full","json","paramTypeArray","RegExp","ParamType","constructorGuard","errors","UNSUPPORTED_OPERATION","operation","match","arrayLength","parseInt","arrayChildren","fromObject","baseType","_isParamType","value","format","result","undefined","map","comp","JSON","parse","stringify","String","join","from","fromString","isParamType","ParamTypify","parseParams","allowIndex","splitNesting","Fragment","_isFragment","isFragment","FunctionFragment","EventFragment","ConstructorFragment","trim","split","substring","_Fragment","_super","apply","arguments","anonymous","inputs","input","isEventFragment","verifyIdentifier","regexParen","forEach","modifier","warn","parseGas","gas","comps","parseModifiers","constant","payable","stateMutability","console","log","verifyState","_Fragment2","_super2","payble","toNumber","isConstructorFragment","parens","_ConstructorFragment","_super3","ouputs","outputs","output","toString","isFunctionFragment","returns","regexIdentifier","accum","depth","offset"],"sources":["../src.ts/fragments.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module"}